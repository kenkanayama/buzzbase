# BuzzBase 開発ルール

## 言語設定
- すべての回答は日本語で行うこと

## 時間・日時の扱い

### 日本時間（JST）前提での開発

**⚠️ 重要**: このプロジェクトでは、**常に日本時間（JST）前提で検討と対応を行うこと**。

#### 基本方針

1. **すべての日時処理は日本時間（JST）を基準とする**
   - タイムゾーン変換は不要（日本時間で統一）
   - UTCへの変換は行わない（特別な理由がある場合を除く）

2. **日時関連の実装における注意事項**
   - 日付の判定・比較は日本時間で行う
   - バッチ処理の実行時刻は日本時間で設定する
   - ユーザーに表示する日時は日本時間で表示する
   - データベースに保存する日時も日本時間を前提とする

3. **具体的な実装例**
   - 投稿から7日経過の判定：日本時間の00:00:00を基準に判定
   - Cloud Schedulerの実行時刻：日本時間で設定（例：毎日23:00 JST）
   - 日付フィルタリング：日本時間の日付境界で判定

4. **コード内での日時処理**
   ```typescript
   // ✅ 正しい実装: 日本時間を前提とした日時処理
   const now = new Date(); // ブラウザ/サーバーのタイムゾーン設定に依存（JST前提）
   const jstDate = new Date(now.toLocaleString('ja-JP', { timeZone: 'Asia/Tokyo' }));
   
   // 7日前の00:00:00を取得（日本時間）
   const sevenDaysAgo = new Date(jstDate);
   sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
   sevenDaysAgo.setHours(0, 0, 0, 0);
   ```

5. **ドキュメント・コメントでの表記**
   - 日時を記載する際は必ず「JST」を明記する
   - 例：「毎日23:00 JSTに実行」「投稿から7日後の00:00:00 JST以降」

#### 例外

以下の場合のみ、UTCや他のタイムゾーンを考慮する：
- 外部APIがUTCを要求する場合（その場合も内部処理はJST前提）
- 国際的な標準規格に準拠する必要がある場合

## デザインシステムの使用

### 必須: デザインシステムガイドラインの参照

フロントエンド開発において、**すべてのUIコンポーネント、スタイリング、レイアウトの実装は、プロジェクト内のデザインシステムガイドラインに従うこと**。

#### デザインシステムドキュメントの場所

以下のファイルを参照すること：

- **デザインシステムガイドライン**: `docs/DESIGN_SYSTEM.md`

#### デザインシステムの参照方法

新しいUIコンポーネントやスタイリングを作成・修正する際は、**必ず以下の手順を実行すること**：

1. **事前にデザインシステムドキュメントを読み込む**
   - `read_file` ツールを使用して `docs/DESIGN_SYSTEM.md` を読み込む
   - カラーパレット、タイポグラフィ、コンポーネントパターンを確認する

2. **デザインシステムに準拠した実装**
   - カラーコードはデザインシステムで定義された値を使用する
     - プライマリ: `#f29801` (オレンジ)
     - セカンダリ: `#e61f13` (レッド)
     - 背景: `#ffffff` (白) または `#fafafa` (淡いグレー)
   - グラデーション、glassmorphism、ダークテーマは使用しない
   - インラインスタイルでカラーを直接指定する（Tailwindのカスタムクラスではなく）

3. **デザインシステムのチェックリストを確認**
   - 実装前に `docs/DESIGN_SYSTEM.md` の「✅ チェックリスト」セクションを確認する
   - すべての項目に準拠していることを確認する

#### デザインシステムの主要な原則

- **背景**: 白（`#ffffff`）または淡いグレー（`#fafafa`）のみ
- **プライマリカラー**: オレンジ（`#f29801`） - ボタン、リンク、ロゴ
- **セカンダリカラー**: レッド（`#e61f13`） - 警告、削除、数値強調
- **テキスト**: ニュートラルカラー（`#262626`, `#525252` など）
- **エフェクト**: グラデーション、glassmorphism は使用しない
- **デザイン**: フラットデザイン、「硬めとポップの中間」を意識

#### 実装例

```tsx
// ✅ 正しい実装: デザインシステムに準拠
<button
  className="px-8 py-4 text-lg font-semibold text-white rounded-lg transition-colors"
  style={{ backgroundColor: '#f29801' }} // デザインシステムのプライマリカラー
  onMouseOver={(e) => e.currentTarget.style.backgroundColor = '#e38500'}
  onMouseOut={(e) => e.currentTarget.style.backgroundColor = '#f29801'}
>
  無料で始める
</button>

// ❌ 間違った実装: グラデーションを使用
<button className="bg-gradient-to-r from-orange-500 to-red-500">
  ボタン
</button>
```

#### デザインシステム違反の回避

以下のような実装は**絶対に避けること**：

- ❌ グラデーション（`bg-gradient-*`）
- ❌ ダークテーマ（`bg-gray-900`, `bg-black` など）
- ❌ glassmorphism（`backdrop-blur`, `bg-white/70` など）
- ❌ デザインシステムで定義されていないカラーコード
- ❌ デザインシステムドキュメントを参照せずにスタイリングを実装

#### デザインシステムの更新

デザインシステムガイドラインを更新する場合は、以下のファイルを更新すること：

- `docs/DESIGN_SYSTEM.md`

---

## インフラ管理方針（Terraform / IaC）

### GCP設定のTerraform管理

**⚠️ 重要**: GCPの設定内容は、可能なものはすべてTerraformで管理すること。

#### 基本方針

1. **Infrastructure as Code（IaC）を徹底する**
   - GCPリソース（Cloud Run、Firestore、Cloud Functions、IAMなど）の設定は、手動でGCPコンソールから行わず、Terraformで定義する
   - 設定の再現性、バージョン管理、レビュー可能性を確保する

2. **Terraformで管理すべきリソース**
   - Cloud Run サービス設定
   - Artifact Registry
   - Cloud Firestore
   - Cloud Functions
   - Cloud Scheduler
   - IAM ポリシー・サービスアカウント
   - VPCネットワーク（必要な場合）
   - Secret Manager（シークレットの存在のみ、値は除く）

3. **Terraformで管理しないもの（例外）**
   - Firebase Authentication の設定（Firebase Console で管理）
   - 機密情報の値（環境変数や `.env` で管理）
   - 一時的な検証・テスト用リソース

#### Terraformファイル構成

すべてのTerraformファイルは `terraform/` ディレクトリに配置し、**論理的なサービスグループごとにファイルを分割**する：

```
terraform/
├── main.tf              # Terraform設定、プロバイダー、API有効化
├── cloud_run.tf         # Cloud Run関連（SA、IAM、サービス、公開アクセス）
├── cloud_functions.tf   # Cloud Functions関連（SA、IAM、ストレージ、関数）
├── cloud_build.tf       # Cloud Build関連（SA、IAM、Artifact Registry、トリガー）
├── secrets.tf           # Secret Manager関連
├── iam_local_dev.tf     # ローカル開発用SA・IAM
├── variables.tf         # 変数定義
├── outputs.tf           # 出力定義
├── functions/           # Cloud Functionsソースコード
│   ├── index.js
│   └── package.json
├── terraform.tfvars     # 変数値（.gitignoreに含む）
└── terraform.tfvars.example  # 変数値のサンプル
```

#### Terraformコーディング規約（ベストプラクティス）

1. **論理的なサービスグループごとにファイルを分割する**
   - 各GCPサービス（Cloud Run、Cloud Functions、Cloud Buildなど）に関連するすべてのリソースを1ファイルにまとめる
   - サービスアカウント、IAMバインディング、サービス本体を同じファイルに記述
   - これにより保守性が向上し、特定サービスの変更時に1ファイルだけ編集すればよい

2. **ファイルの役割**

   | ファイル | 内容 |
   |---|---|
   | `main.tf` | Terraformブロック、プロバイダー設定、API有効化のみ |
   | `cloud_run.tf` | Cloud Run関連のすべて（SA、IAM、サービス、公開アクセス） |
   | `cloud_functions.tf` | Cloud Functions関連のすべて（SA、IAM、ストレージ、関数） |
   | `cloud_build.tf` | Cloud Build関連のすべて（SA、IAM、Artifact Registry、トリガー） |
   | `secrets.tf` | Secret Manager関連 |
   | `iam_local_dev.tf` | 特定サービスに紐づかないSA・IAM |
   | `variables.tf` | 変数定義 |
   | `outputs.tf` | 出力定義 |

3. **新しいGCPサービスを追加する場合**
   - 新しいファイル（例: `cloud_scheduler.tf`）を作成する
   - そのサービスに関連するすべてのリソースを1ファイルにまとめる
   - ファイル冒頭にコメントで内容を説明する

4. **ファイル内の構成順序**
   ```hcl
   # =============================================================================
   # [サービス名] - [説明]
   # =============================================================================
   #
   # このファイルには [サービス名] に関連するすべてのリソースが含まれます:
   #   - サービスアカウント
   #   - IAMバインディング
   #   - [その他のリソース]
   #
   # =============================================================================

   # -----------------------------------------------------------------------------
   # Service Account
   # -----------------------------------------------------------------------------
   resource "google_service_account" "..." { ... }

   # -----------------------------------------------------------------------------
   # IAM Bindings
   # -----------------------------------------------------------------------------
   resource "google_project_iam_member" "..." { ... }

   # -----------------------------------------------------------------------------
   # [リソース本体]
   # -----------------------------------------------------------------------------
   resource "google_..._service" "..." { ... }

   # -----------------------------------------------------------------------------
   # Public Access (必要な場合)
   # -----------------------------------------------------------------------------
   resource "google_..._iam_member" "..." { ... }
   ```

5. **IAMリソースの配置ルール**
   - サービス固有のSA・IAM → そのサービスのファイル（例: `cloud_run.tf`）
   - 複数サービスで共有するSA・IAM → 専用ファイル（例: `iam_local_dev.tf`）

6. **命名規則**
   - ファイル名: `<サービス名>.tf`（スネークケース）
   - リソース名: サービス名を接頭辞に（例: `cloudrun_firestore`, `functions_secret_accessor`）

#### GCP設定変更時のワークフロー

1. **手動で設定しない** - GCPコンソールで直接変更せず、Terraformを使用する
2. **Terraformファイルを更新** - 必要な変更を `.tf` ファイルに反映
3. **プランを確認** - `terraform plan` で変更内容を確認
4. **適用** - `terraform apply` で変更を適用
5. **コミット** - Terraformファイルの変更をGitにコミット

```bash
# Terraformコマンド（Docker環境で実行）
docker compose --profile terraform run --rm terraform plan
docker compose --profile terraform run --rm terraform apply
```

---

## Docker環境でのコマンド実行

基本的にすべてのコマンドはDocker環境内で実行すること。

### フロントエンド関連コマンド
```bash
# npmコマンドの実行
docker compose exec frontend npm install <package>
docker compose exec frontend npm run lint
docker compose exec frontend npm run type-check
docker compose exec frontend npm run build
```

### 開発サーバーの起動
```bash
# フロントエンドのみ
docker compose up frontend

# Firebase Emulator も含める
docker compose --profile emulator up

# バックグラウンドで起動
docker compose up -d frontend
```

### Terraformコマンド
```bash
# Terraform環境を使用
docker compose --profile terraform run --rm terraform init
docker compose --profile terraform run --rm terraform plan
docker compose --profile terraform run --rm terraform apply
```

### 例外：Docker外で実行するコマンド
以下のコマンドはホストマシンで直接実行する：
- `git` 関連のコマンド
- `docker` / `docker compose` コマンド自体
- `gcloud` CLI コマンド

---

## コミットワークフロー

「コミットして」とチャットに入力された場合、以下の手順で実行する：

### 1. 差分の確認
```bash
git status
git diff
git diff --staged
```

### 2. フロントエンドの変更がある場合：ビルドチェック（必須）

**⚠️ 重要**: `frontend/` ディレクトリ内のファイルに変更がある場合は、**必ず以下のチェックを実行してからコミットすること**。

```bash
# 型チェック
docker compose exec frontend npm run type-check

# ビルドチェック（型チェックも含む）
docker compose exec frontend npm run build
```

**チェックが失敗した場合：**
- エラーを修正してから再度チェックを実行する
- すべてのチェックが成功するまでコミットしない

**よくあるエラー例：**
- `TS6133: 'xxx' is declared but its value is never read.` → 未使用のインポートを削除
- `TS2345: Argument of type 'xxx' is not assignable...` → 型の不整合を修正

### 3. ステージング
```bash
git add -A
```

### 4. コミット
コミットメッセージは差分を確認した上で、適切な内容を**日本語**で作成する。

**コミットメッセージのフォーマット:**
```
<type>: <概要>

<詳細説明（必要な場合）>
```

**typeの種類:**
- `feat`: 新しい機能
- `fix`: バグの修正
- `docs`: ドキュメントのみの変更
- `style`: 空白、フォーマット、セミコロン追加など（コードの動作に影響しない変更）
- `refactor`: 仕様に影響がないコード改善（リファクタリング）
- `perf`: パフォーマンス向上関連
- `test`: テスト関連
- `chore`: ビルド、補助ツール、ライブラリ関連

### 5. プッシュ
現在のローカルブランチと同名のリモートブランチにプッシュする：
```bash
git push origin $(git branch --show-current)
```

---

## 技術スタック

### フロントエンド
- **React 18** + **Vite** + **TypeScript**
- **Tailwind CSS** でスタイリング
- **Firebase** Authentication & Firestore
- **React Router DOM** でルーティング

### インフラ
- **GCP**: Cloud Run, Cloud Firestore, Cloud Functions
- **Docker**: ローカル開発環境
- **Terraform**: IaC

### コード品質
- **ESLint** でリンティング（フラットコンフィグ形式）
- **Prettier** でコードフォーマット（Tailwind CSSプラグイン付き）
- **husky** + **lint-staged** でpre-commitフック
- **TypeScript** strict mode

### Pre-commit 自動チェック
コミット時に以下が自動実行される：
- ステージされた `.ts`, `.tsx` ファイルに対して ESLint + Prettier
- ステージされた `.js`, `.jsx`, `.json`, `.css`, `.md` ファイルに対して Prettier

---

## コーディング規約

### TypeScript
- 型定義は `frontend/src/types/` に配置
- `any` 型の使用は避ける
- 厳密な型チェックを有効にする

### React
- 関数コンポーネントを使用
- カスタムフックは `hooks/` ディレクトリに配置
- Contextは `contexts/` ディレクトリに配置
- コンポーネントは機能別にディレクトリ分け

### スタイリング
- Tailwind CSSのユーティリティクラスを使用
- カスタムCSSは最小限に
- `clsx` と `tailwind-merge` を使用してクラス名を結合
- **デザインシステムガイドラインに準拠すること**（上記参照）

### ファイル命名規則
- コンポーネント: PascalCase (`Button.tsx`, `Header.tsx`)
- ユーティリティ: camelCase (`utils.ts`, `firebase.ts`)
- 型定義: `index.ts` または対象のファイル名

---

## プロジェクト構造

```
buzz_base/
├── frontend/           # React アプリ
│   ├── src/
│   │   ├── components/ # UIコンポーネント
│   │   │   ├── auth/   # 認証関連
│   │   │   ├── layout/ # レイアウト
│   │   │   └── ui/     # 汎用UI
│   │   ├── contexts/   # React Context
│   │   ├── hooks/      # カスタムフック
│   │   ├── lib/        # ユーティリティ
│   │   ├── pages/      # ページコンポーネント
│   │   ├── styles/     # グローバルスタイル
│   │   └── types/      # 型定義
│   └── public/         # 静的ファイル
├── docs/               # ドキュメント
│   └── DESIGN_SYSTEM.md  # デザインシステムガイドライン
├── firebase/           # Firestore ルール
├── terraform/          # インフラ定義（Terraform）
│   ├── main.tf         # Terraform設定、プロバイダー、API有効化
│   ├── cloud_run.tf    # Cloud Run関連リソース
│   ├── cloud_functions.tf  # Cloud Functions関連リソース
│   ├── cloud_build.tf  # Cloud Build・Artifact Registry関連
│   ├── secrets.tf      # Secret Manager関連
│   ├── iam_local_dev.tf  # ローカル開発用SA・IAM
│   ├── variables.tf    # 変数定義
│   ├── outputs.tf      # 出力定義
│   └── functions/      # Cloud Functionsソースコード
├── docker-compose.yml  # 開発環境
├── Dockerfile          # 本番用
└── Dockerfile.dev      # 開発用
```

---

## 環境変数

環境変数は `.env` ファイルで管理する（`.gitignore` に含まれている）。
設定例は `env.example` を参照。

必要な環境変数:
- `VITE_FIREBASE_API_KEY`
- `VITE_FIREBASE_AUTH_DOMAIN`
- `VITE_FIREBASE_PROJECT_ID`
- `VITE_FIREBASE_STORAGE_BUCKET`
- `VITE_FIREBASE_MESSAGING_SENDER_ID`
- `VITE_FIREBASE_APP_ID`

